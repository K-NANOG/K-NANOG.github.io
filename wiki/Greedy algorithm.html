
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Greedy algorithm</title>
        <link rel="stylesheet" href="wiki.css">
    </head>
    <body>
        <div class="container">
            <section class="intro">
                <h2>Greedy algorithm</h2>
                <p>A greedy algorithm is any algorithm that follows the problem-solving heuristic of making the locally optimal choice at each stage. In many problems, a greedy strategy does not produce an optimal solution, but a greedy heuristic can yield locally optimal solutions that approximate a globally optimal solution in a reasonable amount of time.</p>
<p>For example, a greedy strategy for the travelling salesman problem (which is of high computational complexity) is the following heuristic: "At each step of the journey, visit the nearest unvisited city." This heuristic does not intend to find the best solution, but it terminates in a reasonable number of steps; finding an optimal solution to such a complex problem typically requires unreasonably many steps. In mathematical optimization, greedy algorithms optimally solve combinatorial problems having the properties of matroids and give constant-factor approximations to optimization problems with the submodular structure.</p>
<p>Specifics</p>
<p>Greedy algorithms produce good solutions on some mathematical problems, but not on others. Most problems for which they work will  have two properties:</p>
<p>Greedy choice property</p>
<p>Whichever choice seems best at a given moment can be made and then (recursively) solve the remaining sub-problems. The choice made by a greedy algorithm may depend on choices made so far, but not on future choices or all the solutions to the subproblem.  It iteratively makes one greedy choice after another, reducing each given problem into a smaller one. In other words, a greedy algorithm never reconsiders its choices. This is the main difference from dynamic programming, which is exhaustive and is guaranteed to find the solution. After every stage, dynamic programming makes decisions based on all the decisions made in the previous stage and may reconsider the previous stage's algorithmic path to the solution.</p>
<p>Optimal substructure</p>
<p>"A problem exhibits optimal substructure if an optimal solution to the problem contains optimal solutions to the sub-problems."</p>
<p>Cases of failure</p>
<p>Greedy algorithms fail to produce the optimal solution for many other problems and may even produce the unique worst possible solution. One example is the travelling salesman problem mentioned above: for each number of cities, there is an assignment of distances between the cities for which the nearest-neighbour heuristic produces the unique worst possible tour.</p>
<p>For other possible examples, see horizon effect.</p>
<p>Types</p>
<p>Greedy algorithms can be characterized as being 'short sighted', and also as 'non-recoverable'. They are ideal only for problems that have an 'optimal substructure'. Despite this, for many simple problems, the best-suited algorithms are greedy. It is important, however, to note that the greedy algorithm can be used as a selection algorithm to prioritize options within a search, or branch-and-bound algorithm. There are a few variations to the greedy algorithm:</p>
<p>Pure greedy algorithms</p>
<p>Orthogonal greedy algorithms</p>
<p>Relaxed greedy algorithms</p>
<p>Theory</p>
<p>Greedy algorithms have a long history of study in combinatorial optimization and theoretical computer science. Greedy heuristics are known to produce suboptimal results on many problems, and so natural questions are:</p>
<p>For which problems do greedy algorithms perform optimally?</p>
<p>For which problems do greedy algorithms guarantee an approximately optimal solution?</p>
<p>For which problems are the greedy algorithm guaranteed not to produce an optimal solution?</p>
<p>A large body of literature exists answering these questions for general classes of problems, such as matroids, as well as for specific problems, such as set cover.</p>
<p>Matroids</p>
<p>A matroid is a mathematical structure that generalizes the notion of linear independence from vector spaces to arbitrary sets. If an optimization problem has the structure of a matroid, then the appropriate greedy algorithm will solve it optimally.</p>
<p>Submodular functions</p>
<p>A function </p>
<p>        f</p>
<p>    {\displaystyle f}</p>
<p> defined on subsets of a set </p>
<p>        Ω</p>
<p>    {\displaystyle \Omega }</p>
<p> is called submodular if for every </p>
<p>        S</p>
<p>        ,</p>
<p>        T</p>
<p>        ⊆</p>
<p>        Ω</p>
<p>    {\displaystyle S,T\subseteq \Omega }</p>
<p> we have that </p>
<p>        f</p>
<p>        (</p>
<p>        S</p>
<p>        )</p>
<p>        +</p>
<p>        f</p>
<p>        (</p>
<p>        T</p>
<p>        )</p>
<p>        ≥</p>
<p>        f</p>
<p>        (</p>
<p>        S</p>
<p>        ∪</p>
<p>        T</p>
<p>        )</p>
<p>        +</p>
<p>        f</p>
<p>        (</p>
<p>        S</p>
<p>        ∩</p>
<p>        T</p>
<p>        )</p>
<p>    {\displaystyle f(S)+f(T)\geq f(S\cup T)+f(S\cap T)}</p>
<p>.</p>
<p>Suppose one wants to find a set </p>
<p>        S</p>
<p>    {\displaystyle S}</p>
<p> which maximizes </p>
<p>        f</p>
<p>    {\displaystyle f}</p>
<p>. The greedy algorithm, which builds up a set </p>
<p>        S</p>
<p>    {\displaystyle S}</p>
<p> by incrementally adding the element which increases </p>
<p>        f</p>
<p>    {\displaystyle f}</p>
<p> the most at each step, produces as output a set that is at least </p>
<p>        (</p>
<p>        1</p>
<p>        −</p>
<p>        1</p>
<p>          /</p>
<p>        e</p>
<p>        )</p>
<p>          max</p>
<p>            X</p>
<p>            ⊆</p>
<p>            Ω</p>
<p>        f</p>
<p>        (</p>
<p>        X</p>
<p>        )</p>
<p>    {\displaystyle (1-1/e)\max _{X\subseteq \Omega }f(X)}</p>
<p>. That is, greedy performs within a constant factor of </p>
<p>        (</p>
<p>        1</p>
<p>        −</p>
<p>        1</p>
<p>          /</p>
<p>        e</p>
<p>        )</p>
<p>        ≈</p>
<p>        0.63</p>
<p>    {\displaystyle (1-1/e)\approx 0.63}</p>
<p> as good as the optimal solution.</p>
<p>Similar guarantees are provable when additional constraints, such as cardinality constraints, are imposed on the output, though often slight variations on the greedy algorithm are required. See  for an overview.</p>
<p>Other problems with guarantees</p>
<p>Other problems for which the greedy algorithm gives a strong guarantee, but not an optimal solution, include</p>
<p>Set cover</p>
<p>The Steiner tree problem</p>
<p>Load balancing</p>
<p>Independent set</p>
<p>Many of these problems have matching lower bounds; i.e., the greedy algorithm does not perform better than the guarantee in the worst case.</p>
<p>Applications</p>
<p>Greedy algorithms typically (but not always) fail to find the globally optimal solution because they usually do not operate exhaustively on all the data. They can make commitments to certain choices too early, preventing them from finding the best overall solution later. For example, all known greedy coloring algorithms for the graph coloring problem and all other NP-complete problems do not consistently find optimum solutions. Nevertheless, they are useful because they are quick to think up and often give good approximations to the optimum.</p>
<p>If a greedy algorithm can be proven to yield the global optimum for a given problem class, it typically becomes the method of choice because it is faster than other optimization methods like dynamic programming. Examples of such greedy algorithms are Kruskal's algorithm and Prim's algorithm for finding minimum spanning trees and the algorithm for finding optimum Huffman trees.</p>
<p>Greedy algorithms appear in the network routing as well.  Using greedy routing, a message is forwarded to the neighbouring node which is "closest" to the destination. The notion of a node's location (and hence "closeness") may be determined by its physical location, as in geographic routing used by ad hoc networks.  Location may also be an entirely artificial construct as in small world routing and distributed hash table.</p>
<p>Examples</p>
<p>The activity selection problem is characteristic of this class of problems, where the goal is to pick the maximum number of activities that do not clash with each other.</p>
<p>In the Macintosh computer game Crystal Quest the objective is to collect crystals, in a fashion similar to the travelling salesman problem. The game has a demo mode, where the game uses a greedy algorithm to go to every crystal. The artificial intelligence does not account for obstacles, so the demo mode often ends quickly.</p>
<p>The matching pursuit is an example of a greedy algorithm applied on signal approximation.</p>
<p>A greedy algorithm finds the optimal solution to Malfatti's problem of finding three disjoint circles within a given triangle that maximize the total area of the circles; it is conjectured that the same greedy algorithm is optimal for any number of circles.</p>
<p>A greedy algorithm is used to construct a Huffman tree during Huffman coding where it finds an optimal solution.</p>
<p>In decision tree learning, greedy algorithms are commonly used, however they are not guaranteed to find the optimal solution.</p>
<p>One popular such algorithm is the ID3 algorithm for decision tree construction.</p>
<p>Dijkstra's algorithm and the related A* search algorithm are verifiably optimal greedy algorithms for graph search and shortest path finding.</p>
<p>A* search is conditionally optimal, requiring an "admissible heuristic" that will not overestimate path costs.</p>
<p>Kruskal's algorithm and Prim's algorithm are greedy algorithms for constructing minimum spanning trees of a given connected graph. They always find an optimal solution, which may not be unique in general.</p>
<p>The Sequitur and Lempel-Ziv-Welch algorithms are greedy algorithms for grammar induction.</p>
<p>See also</p>
<p>References</p>
<p>Sources</p>
<p>External links</p>
<p>"Greedy algorithm", Encyclopedia of Mathematics, EMS Press, 2001 [1994]</p>
<p>Gift, Noah. "Python greedy coin example".</p>

            </section>
        </div>
    </body>
    </html>
    