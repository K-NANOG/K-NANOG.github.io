[00:00] This is a secure line. Authenticate.

[00:07] Lima, Whiskey, Niner.

[00:17] Message received.

[00:20] Amongst the sea of agents, there's a mole.

[00:22] We can't openly communicate. I can only trust a select few.

[00:37] I need to exchange crucial information without anyone noticing.

[00:45] There's a massive yet hidden chain of command operating behind the scenes. I'm only privy to a small part of it.

[00:53] There's been too many leaks.

[01:03] Stop. We're not here to talk about espionage.

[01:06] Believe it or not, the processes on your computer face a similar communication challenge every single day.

[01:12] The issue of secure interprocess communication has been a critical part of computer architecture for decades.

[01:19] Today we're here to talk about one of the most influential implementations of interprocess communication that affects billions of devices worldwide, the Android Binder.

[01:30] Let's get wired in.

[01:34] Interprocess communication, Laila Bandroid.

[01:39] Alright, I'm going to level with you.

[01:41] What we're about to dive into isn't your average tech tutorial.

[01:45] We're about to embark on a journey through one of the most complex and most crucial systems in modern mobile computing.

[01:52] This video is going to be dense. It's going to be technical.

[01:55] And at times it might even be a bit challenging.

[01:58] But here's the thing. If you stick with me, if you push through those moments of confusion, you're going to come out the other side with a deep understanding of something that affects billions of devices worldwide.

[02:10] You're not just going to learn about Android.

[02:12] You're going to understand how modern operating systems coordinate their internal components, how they seamlessly communicate between apps and how they manage to do so without us even realizing it.

[02:25] Let's begin with our foundational problem.

[02:28] How can two separate programs communicate with each other without compromising the system's security or efficiency?

[02:35] In computers, we often have multiple processes running simultaneously, each in its own isolated memory space.

[02:42] These processes need to share information with each other and coordinate their actions, much like two spies needing to transfer some critical information between each other.

[02:53] Seems deceivingly simple. Just have one process write data somewhere and the other person read it.

[03:00] Whoa, did you see that? We just opened up a huge can of worms.

[03:05] First of all, how is the other process or spy supposed to know when new data is available?

[03:11] What if we both try to write data at the same time?

[03:14] How do we make sure that data doesn't get corrupted or tampered with during transfer?

[03:19] And how do we maintain security so that no other prying eyes see what we're doing?

[03:25] I think we better slow down for a second before we get too deep in the weeds.

[03:29] Let's talk about the first thing we need to implement. Process isolation.

[03:34] Early computers ran one process at a time, so process isolation was a non-issue.

[03:40] But with the advent of multitasking operating systems, we now have to worry about this.

[03:45] Think about it. If all processes are open, no data is private.

[03:53] Not only that, but if one process crashes, the whole system can crash.

[03:59] One of the first computers to implement process isolation was the Atlas supercomputer in 1962,

[04:09] which I've actually made a previous video on if you'd like to learn more.

[04:13] But how does process isolation work in a modern context and more specifically in Android context?

[04:20] At the end of the day, Android is built on top of the Linux kernel, which gives us some core security features for free.

[04:27] Each process in a Linux system is assigned a unique process ID or PID for short.

[04:33] The PID is used in the kernel to track and manage the process, also ensuring that each process has its own virtual address space.

[04:42] The memory management unit of the CPU, along with the Linux kernel, ensures that processes can only access their own allocated memory and not the memory of other processes.

[04:54] Now, there can be some tricky exceptions to this, but for the most part, that's how it works.

[04:59] Android does something a little special, though, that is a bit unconventional compared to what you would expect from, say, a desktop or server Linux installation.

[05:10] By default, for each app that is installed, Android assigns a unique user ID or UID for short.

[05:17] In other words, each Android app runs as a separate Linux user.

[05:22] Each UID gets its own directory protecting processes and file systems from other applications.

[05:29] It's kind of like putting special documents in a folder.

[05:36] If I'm program A, we each get our own separate folder to store our own data in.

[05:43] Neither of us by default can see the contents of other programs folders.

[05:48] We're sandboxed by default.

[05:50] And now if program B crashes, I can continue to run just fine.

[05:58] So there you have it. We've solved the issue of process isolation, at least at a basic level.

[06:03] We have security, but no ability to communicate.

[06:08] Let's go back to our spy scenario.

[06:10] We have two agents and they need to exchange items with each other.

[06:14] What's the simplest way that I can achieve this?

[06:16] I could just leave the item here in the open and they're able to stumble across it, especially if they know exactly where to look.

[06:24] It's not great from a security standpoint, but it is a start.

[06:28] Just like our agents have to communicate, processes in a computer system actually have to communicate all the time.

[06:35] One of the earliest examples of interprocess communication came from the IBM System 360 introduced in 1964.

[06:43] Its operating system, OS 360, had to manage multiple jobs running concurrently, necessitating some form of job to job communication.

[06:52] The solution was simple, albeit primitive.

[06:55] Jobs could communicate by reading and writing from a shared area.

[06:59] Later, in the 70s, early UNIX systems followed a similar methodology.

[07:04] It was quite common for programmers to use the slash temp directory as a common ground for simple interprocess communication.

[07:12] This method also aligned well with UNIX's everything is a file philosophy.

[07:17] So if we have two processes that are otherwise sandboxed from each other, we now have this special slash temp folder that each of us can read and write from to exchange information.

[07:28] Let's think about how this would work in an Android context.

[07:31] Say you've written some notes in a note taking app and now you want to send it in your email application, which is a separate sandboxed process.

[07:39] One of the simpler ways we could solve this is a variation of the UNIX philosophy.

[07:45] In Android, it's fairly common for applications to have read and write access to the SD card directory.

[07:51] We could just dump what we need in there and read it when the time comes.

[07:55] Let's hop into the computer and examine how this would look on a real system.

[07:59] Now, what I've done here is I've created two example Android applications.

[08:03] One is a very simple notepad application and the other is a very simple email application.

[08:09] And they're going to be using the SD card to send information between the two applications.

[08:15] Now, the notepad app is going to write to the SD card and the email app is going to read from the SD card since both applications have access to this shared directory.

[08:25] If we take a quick look at the notepad application, you can see it's just writing to SD card notepad shared dot text.

[08:32] And then the email application is going to be taking values from SD card notepad shared dot text and then adding that to its display up here.

[08:41] Let's take a quick look at what that looks like when it's executing.

[08:44] First, let's see. There's nothing inside of our SD card except the regular things.

[08:48] There's no shared file. So let's run our notepad application.

[08:52] Here we have it. Let's add a note, a special note.

[08:56] I have a mission for you.

[09:03] And let's send this to our email application.

[09:06] Share. You can see we successfully saved this to the SD card.

[09:10] So now we have this notepad shared dot text that is now available for the other application to read in.

[09:18] Let's go to our email app and see if that worked.

[09:20] My email. Sure enough, our email is ready to go.

[09:23] I have a mission for you. In case you didn't realize it, we've got a pretty major problem here.

[09:27] There's effectively no security.

[09:29] Any malicious application that has read write access to the SD card can now spy on all interprocess communication of our primitive example.

[09:38] Clearly, a more robust solution is necessary in order to create a secure operating system.

[09:44] Agent, we've detected a breach in our communication protocols.

[09:48] The dead drop system is compromised.

[09:51] We have reason to believe enemy Intel is intercepting our messages.

[09:55] Understood. When's our next move, Colonel?

[09:57] We're switching to a more secure method.

[09:59] I've arranged for a courier to deliver your next mission briefing in person.

[10:03] This ensures the Intel reaches you and only you.

[10:07] Roger that. When is the rendezvous?

[10:09] Now.

[10:18] Much like our spy agents, a significant improvement can be made in the security of interprocess communication by sending messages process to process

[10:27] instead of just a shared area that anybody could stumble upon.

[10:30] It's difficult to say exactly which early computer system was the first to widely implement more sophisticated IPC mechanisms.

[10:38] There was a lot of interesting competition between various academic and commercial settings.

[10:44] That being said, Multics developed as a collaboration between the two companies.

[10:50] In the mid 1960s was one of the earlier systems to implement advanced IPC techniques such as interprocess signaling.

[10:58] Later in the 1970s, Bell Labs introduced pipes as the fundamental IPC mechanism of Unix,

[11:05] a unidirectional point to point scheme that was developed by the company.

[11:11] In today's era of computing, modern operating systems such as Android support more complex interactions between processes.

[11:19] Binder is the main IPC system of Android.

[11:23] But before we get deeper into how exactly the binder works, let's reestablish the fundamental problem here.

[11:30] We've got process isolation. We've got indirect communication.

[11:34] Now we want a method of direct communication between processes to improve our security posture.

[11:41] Going back to our example notes and email applications, let's talk about the setup.

[11:46] Instead of just copying our notes app output to any shared area, we want to use the same method to create a new network.

[11:55] Let's talk about the setup. Instead of just copying our notes app output to any shared directory that any application can read from,

[12:03] including malicious ones, it would be better to send it point to point.

[12:08] We can't go into all the details yet, and this is an oversimplification.

[12:12] But what if we imagined a third application, this black box we call the binder that handles all the processing and delivery of messages for us.

[12:22] That way, the notes app can communicate with the email app seemingly directly, with our special courier making sure our messages get to the right place.

[12:31] Let's look at some code. Now I've added the next level of sophistication inside of my example notepad app and example email app so that we can facilitate direct app to app communication.

[12:42] This way, we don't have to use the SD card as a shared directory that any application could potentially get access to.

[12:49] If we take a look at the email code, there's a brand new communication service that's been added to the code, and this is going to be able to handle messages directly from incoming applications.

[13:00] You can see we're using our special binder to be able to facilitate this kind of communication.

[13:06] If we go over to our notepad app, we have a connection that's going to be made to this service that's being exposed inside of the email application.

[13:15] It's going to be able to connect to this service, bind to it successfully, and then be able to send messages directly to that email application.

[13:24] We're even going to be able to see that the notepad app can now directly trigger the email application instead of having to go around through different applications and go notepad and then email.

[13:35] Let's execute our new applications.

[13:39] I'm going to go over to my emulator, and first of all, we have our new version of the notepad application.

[13:45] So let's type a special message.

[13:48] I have a mission for you.

[13:53] And now before we had to send this, write this to the SD card, and then open up the email application ourselves.

[13:59] But here we can just click share.

[14:02] And now we directly have our special message inside of our email application.

[14:06] All this is well and good, but we're making some pretty heavy assumptions here.

[14:10] What is this mysterious program? Who is delivering these messages?

[14:14] And why do I, as the program, know so little of what's happening behind the scenes?

[14:27] Much like our hidden courier delivering messages between agents, Android has a courier of its own.

[14:33] Binder is the main interprocess communication system for Android, but it actually predates Android by a significant amount.

[14:40] Binder started off as a project called OpenBinder by B-Ink for their BOS operating system at the tail end of the 1990s.

[14:49] B-Ink was then acquired by Palm Inc., known for their personal digital assistants, most famously Palm Pilot.

[14:58] Palm eventually split off a subsidiary to license their mobile operating system, Palm OS.

[15:04] And development of OpenBinder continued under this new Palm Source division.

[15:09] Palm ended up switching to Linux instead of a microkernel-based OS, so Binder was then ported over to Linux and open sourced around 2005.

[15:19] Diane Hackborn, one of the key engineers of OpenBinder, was hired by Google to join the Android team.

[15:26] The Android team quickly realized that a robust yet efficient IPC was needed for their OS.

[15:31] Being that OpenBinder was already ported to Linux and their hardware target was a measly 200MHz ARM device, using OpenBinder as the main IPC mechanism for Android was a no-brainer.

[15:44] OpenBinder was used as-is in the early versions of Android, but was eventually completely rewritten in 2008.

[15:51] Today's Binder may look quite different from those early iterations, however, many of the core principles remain the same.

[15:58] That's enough of a history lesson, let's talk about how it works.

[16:01] As I mentioned earlier, Binder is the main interprocess communication system for Android.

[16:06] It spans across two different worlds, kernel space and user space, to perform its duties.

[16:12] The kernel space implementation is necessary to give Binder the permissions it needs to be able to communicate and send messages across processes.

[16:21] Remember, we can't use a file system-based interprocess communication mechanism because in Android we lack a world-writable directory from the application side for security reasons.

[16:33] The user space portion of the Binder is required so that applications are able to communicate to Binder, much like a mail person, each application sends its interprocess messages, or letters, over to Binder in user space.

[16:47] Binder is implemented in user space as classes inside the Android framework that applications can call whenever they have a message for another app.

[16:56] The kernel space area of the Binder is actually implemented as a kernel driver, which handles many low-level operations.

[17:03] Managing memory and transmitting data across processes are all handled in kernel space.

[17:09] The binder driver in the kernel creates a file, known as a device file, at slash dev slash binder,

[17:16] which serves as the gateway for processes in user space to send commands and data to the binder driver.

[17:23] Classes inside the Android system make the direct IOCTL system calls to this file to send messages.

[17:30] This shields application developers from the complexity of direct communication.

[17:36] Instead, devs can use high-level Android APIs, which act as a proxy, handling the IPC operations underneath.

[17:44] This way, app devs can focus on application logic instead of all the technical details of interprocess communication.

[17:51] Pretty neat, right? Let's take a look at where the real binder file is located on an Android device.

[17:57] I currently have my Android emulator running over here, and so I'm going to get a shell to that.

[18:02] Let's do ADB shell, then run a super user, and let's change directories to our slash dev directory,

[18:10] and then list out all the files and folders inside of this directory.

[18:15] And I'm going to grab for anything binder related. Here we go.

[18:21] So here you can see our binder gateway file to the binder driver.

[18:26] Now you may also notice there are multiple other binder related files in this directory.

[18:31] The slash dev slash binder file is used for general purpose binder communication across apps and services,

[18:39] but sometimes there are also other device files for hardware specific needs, for example,

[18:45] or vendor specific needs for binder communication.

[18:48] Now even though there are sometimes different binder device files exposed,

[18:52] they still interface with the same binder driver underneath.

[19:08] By routing all of our agents' communication through headquarters,

[19:13] we've successfully solved the issue of our assets otherwise being isolated from each other.

[19:18] The security risks are now mitigated, and the burden of safeguarding messages now falls on HQ,

[19:23] not the individual agents.

[19:25] But if I'm being pretty honest, it's getting quite overwhelming here.

[19:29] Messages of various data types are flowing in from agents' databases,

[19:33] SD cards, phone calls, letters, secure radio transmissions, and more.

[19:38] We don't really have a centralized process to handle this amount of data

[19:42] or to route information in a logical manner.

[19:45] There's got to be a better way.

[19:48] Let's think about this from a computing perspective.

[19:52] Now that we've got an actual mechanism for sending messages back and forth,

[19:56] we can actually use this to send messages back and forth.

[20:00] Now that we've got an actual mechanism for sending messages back and forth

[20:04] between applications using the Android binder,

[20:07] we still need to establish some sort of organizational process.

[20:11] And there's a few different topics that we need to consider.

[20:15] How do we decide what order to send messages in?

[20:18] Also, how do we keep track of when messages have already been sent,

[20:22] or even store messages that still need to be sent?

[20:25] Among the various data structures available to us,

[20:28] this is probably the most logical choice.

[20:31] To give an overview, a queue is a concept in computer science

[20:34] for handling data in a specific order.

[20:37] Standard queues work in a first-in, first-out order, or FIFO for short.

[20:42] Essentially, this means that the first item to arrive

[20:46] is also going to be the first item processed and then removed.

[20:53] In the context of Android's binder,

[20:56] it means that messages are going to be processed

[20:59] in the order in which they have been received.

[21:01] The binder driver oversees these message queues

[21:04] for every single Android app or service

[21:07] that wants to make an interprocess communication request.

[21:10] Going back to our spy analogy,

[21:13] think of it like a list of messages from each agent

[21:16] that needs to be organized and processed.

[21:19] Generally, each binder object in a process is allocated

[21:22] an incoming queue and an outgoing queue.

[21:25] Think of it like your inbox and outbox.

[21:28] The outgoing queue stores and manages messages

[21:31] generated by the current process that are destined for other processes.

[21:35] Conversely, the inbound queue collects and holds messages

[21:39] sent by other processes that are intended for the current process to receive.

[21:43] Each message request is encapsulated as a transaction.

[21:47] Each transaction contains a parcel,

[21:50] which is a data structure that stores the actual payload and metadata.

[21:54] This parcel acts as a standardized container

[21:57] for serializing and deserializing data types

[22:00] across process boundaries.

[22:03] The binder driver is like headquarters.

[22:06] It serves as the central manager for processing all IPC transactions

[22:10] sent over the device.

[22:13] Whew, that was a lot.

[22:16] One extra note for you Android developers out there.

[22:19] Each Android application or service making IPC requests

[22:23] actually creates a dedicated binder object

[22:26] that serves as a proxy for communication

[22:29] with the binder driver on the backend.

[22:32] In other words, going back to our spy scenario,

[22:35] HQ handles all the behind-the-scenes work,

[22:38] sorting, routing, and delivering messages,

[22:41] but each agent only needs to interact with HQ to do so.

[22:45] Pretty neat, right?

[22:49] If HQ only accepted one type of data,

[22:52] it would severely limit the information that could be shared,

[22:55] making some missions impossible.

[22:58] Agents should be able to send whatever type of intelligence

[23:01] they gather without limitations.

[23:04] The data is stored in a container,

[23:07] which is a container that is used to store data

[23:10] and is used to store data.

[23:13] The data is stored in a container,

[23:16] and the data is stored in a container

[23:19] that is used to store data.

[23:22] The data is stored in a container

[23:25] that is used to store data.

[23:28] At each HQ, we have to efficiently process

[23:31] diverse information without needing separate divisions

[23:34] for each data type.

[23:37] Similar to how the agency is able to process

[23:40] diverse forms of information from their operatives,

[23:43] we can't really see the exact data that we received

[23:46] or sent and received, but let's focus more directly

[23:49] on what data actually looks like inside of these parcels.

[23:52] Parcel objects themselves are generic data buffers

[23:55] that are optimized for transmission across Android.

[23:58] The data inside of these objects supports

[24:01] a diverse range of fundamental data types,

[24:04] such as integers, long integers, floating point numbers,

[24:07] double precision floating point numbers, and text strings.

[24:10] Parcel objects also support custom objects

[24:13] created and defined by Android developers.

[24:16] It's kind of like letting our spy agents give HQ custom data.

[24:19] As long as they tell HQ how to decrypt their messages,

[24:22] almost anything goes.

[24:25] To send custom data in Android, developers simply need

[24:28] to implement a special interface called Parcelable,

[24:31] which is provided by the Android framework.

[24:34] This allows developers to describe the format

[24:37] and contents of the data and how it should be handled.

[24:40] Serialization and flattening of parcel data

[24:43] are optional techniques that a developer can use

[24:46] for additional optimization. It's really the best

[24:49] of both worlds. The Android framework provides methods

[24:52] to simplify the process of writing and reading data

[24:55] from parcels, but developers also have flexibility

[24:58] for how they implement these for their particular needs.

[25:01] Going back to our spy scenario, it's kind of like

[25:04] how HQ can give agents suggestions and tooling

[25:07] for sending their messages, but if they need

[25:10] something more custom, they still have the ability to do so.

[25:13] Skilled as they may be, we don't expect

[25:16] our agents to be experts in everything.

[25:19] Hence why, here at HQ, we equip our operatives

[25:22] with a covert radio transmission system.

[25:25] Welcome, channel loader one.

[25:28] This system abstracts away many of the complex

[25:31] security steps they would normally have to take

[25:34] to communicate with us. As long as the agent sends us

[25:37] the message in the format we're expecting,

[25:40] it's a speedy way to get a message to HQ

[25:43] without additional fuss.

[25:46] Remember when we were talking earlier about all

[25:49] the different ways Android developers can interact

[25:52] with parcel objects? It can get pretty brittle

[25:55] and challenging to interface with these low-level

[25:58] implementations directly. Wouldn't it be nice

[26:01] if we had some sort of abstraction? Something like

[26:04] a wrapper? One of the most

[26:07] used wrappers around Binder includes a very special

[26:10] message type in Android, intents.

[26:13] Much like the covert radio systems that HQ

[26:16] gives the agents, intents are a quick way

[26:19] to transmit data that gets rid of a lot of the

[26:22] hard stuff. Intents are one of the most common methods

[26:25] for IPC within Android. Services, applications,

[26:28] and even components inside of applications

[26:31] use intent objects to transmit data. For example,

[26:34] let's say you're in the Yelp app and you decide to try

[26:37] out a new sushi restaurant. You click on the address

[26:40] of the restaurant and it magically opens up the address

[26:43] in Google Maps. How did Google Maps know it needed

[26:46] to be open? And how did it know which address to

[26:49] go to? Underneath, the Yelp application is simply

[26:52] sending an intent message defining what kind of action

[26:55] needs to be performed as well as what data is relevant,

[26:58] which in this case is the destination address.

[27:01] Google Maps is listening for these messages and has defined

[27:04] that it's going to open up the address defined

[27:07] inside of the intent object. So next time you're

[27:10] using an Android phone, take a moment to notice that

[27:13] most of these interactions between applications

[27:16] are silently calling the binder on the back end.

[27:22] This is your new identity.

[27:25] Memorize every detail. Your name,

[27:28] your history. They no longer exist.

[27:31] This is who you are now. The document also contains

[27:34] a secure ID code. That cipher is how we will deliver

[27:38] messages to you. This radio is your lifeline.

[27:42] Missions will get routed through that radio,

[27:45] encrypted through your cipher. We have all your

[27:48] information in our database. We have all the information

[27:51] in our database. The old you dies today.

[27:54] Don't mess this up.

[28:00] While we've addressed message formatting, storage, and

[28:03] transmission, we still have other challenges to consider.

[28:06] One of the more interesting aspects of interprocess

[28:09] communication is message routing and service discovery.

[28:12] A fascinating historical example of service discovery

[28:15] comes from an experimental operating system

[28:18] developed at Xerox's park in the late 1970s.

[28:21] The researchers created an operating system called

[28:24] Cedar, built on top of the Mesa programming language.

[28:27] One of Cedar's key features was a component called

[28:30] Clearinghouse. Clearinghouse was a network-wide

[28:33] naming and authentication system. Clearinghouse

[28:36] provided a hierarchical namespace for naming and

[28:39] locating resources, including services, across a

[28:42] distributed network. Processes that were used to

[28:45] connect to services across the distributed system.

[28:48] Let's examine this from the perspective of the centralized

[28:51] manager of Android, the binder. Picture this.

[28:54] You have a ton of messages formatted, queued up, and

[28:57] otherwise ready to go. As the message manager, how do

[29:00] you know where to deliver each message? To effectively

[29:03] route the messages, each message requires a target

[29:06] location. Message reception requires a target location.

[29:09] The message is a single message.

[29:12] The message requires a target location. Message

[29:15] recipients would need to register beforehand with

[29:18] address and delivery details in order to receive their

[29:21] messages. In Android, this is solved with something

[29:24] called the service manager. The service manager

[29:27] serves as the centralized registry where both system

[29:30] services and applications can register themselves

[29:33] to receive messages via the binder.

[29:36] Each client must register under a unique name,

[29:39] much like how each agent has a unique contact address.

[29:42] So that other processes can specify their service

[29:45] name as the target. When an app or service needs to

[29:48] send a message to another service, it queries the

[29:51] service manager with the destination service name.

[29:54] The service manager then returns a binder object,

[29:57] which the sender can then use to communicate with the

[30:00] intended recipient. Remember, because Android is an

[30:03] open source operating system at the end of the day,

[30:06] we can take a look at the real source code to see how

[30:09] service discovery works in a modern operating system.

[30:12] Here we're taking a look at the actual Android

[30:15] source code. Remember those unique names that

[30:18] services have to register under? This is how the

[30:21] actual Android system names common services running

[30:24] on the device. If you're an Android developer,

[30:27] some of these might look familiar to you. There is

[30:30] the phone service, for example, that is registered

[30:33] for getting the telephony manager. This lets you use

[30:36] all the different telephony features on the device,

[30:39] like making a phone call, for example. If we scroll

[30:42] down, we can find the clipboard service for

[30:45] retrieving the clipboard manager. This lets you

[30:48] access or modify contents of the Android clipboard.

[30:51] And there are so many other services on here as well.

[30:54] If you're curious, try looking at this file in the

[30:57] Android source code and check out all the other

[31:00] services that you never knew were running in the

[31:03] background of your device. You can find relevant

[31:06] links in the comments section of this video.

[31:31] .

[31:52] In the Android world, despite the centralized

[31:55] manager's comprehensive knowledge of all service

[31:58] services, the Android system is a very

[32:01] complex system. Communication between services and

[32:04] applications is restricted based on predefined

[32:07] access rules. This is an essential component of

[32:10] maintaining the security of the overall system.

[32:13] Services can specify permissions required for

[32:16] communication. Clients must then request the

[32:19] appropriate privileges before attempting to interact

[32:22] with these services. The Android system verifies

[32:25] the permissions required for any requested binder

[32:28] transactions. Applications are able to declare the

[32:31] permissions they intend to request within their

[32:34] main configuration file known as the Android

[32:37] manifest.

[32:55] .

[33:15] We previously talked about how the binder uses a

[33:18] queue-based architecture for handling the

[33:21] transmission of messages. The queue works well for

[33:24] different purposes. If the binder is not

[33:27] transmitting messages at a time, the binder will

[33:30] not be able to transmit messages at a time.

[33:33] .

[33:35] .

[33:37] .

[33:39] .

[33:41] .

[33:43] .

[33:45] .

[33:47] .

[33:49] .

[33:51] .

[33:53] .

[33:55] .

[33:57] .

[33:59] .

[34:01] .

[34:03] .

[34:05] .

[34:07] .

[34:09] .

[34:11] .

[34:13] .

[34:15] .

[34:17] .

[34:19] .

[34:21] .

[34:23] .

[34:25] .

[34:27] .

[34:29] .

[34:31] .

[34:33] .

[34:35] .

[34:37] .

[34:39] .

[34:41] .

[34:43] .

[34:45] .

[34:47] .

[34:49] .

[34:51] .

[34:53] .

[34:55] .

[34:57] .

[34:59] .

[35:01] .

[35:03] .

[35:05] .

[35:07] .

[35:09] .

[35:11] .

[35:13] .

[35:15] .

[35:17] .

[35:19] .

[35:21] .

[35:23] .

[35:25] .

[35:27] .

[35:29] .

[35:31] .

[35:33] .

[35:35] .

[35:37] .

[35:39] .

[35:41] .

[35:43] .

[35:45] .

[35:47] .

[35:49] .

[35:51] .

[35:53] .

[35:55] .

[35:57] .

[35:59] .

[36:01] .

[36:03] .

[36:05] .

[36:07] .

[36:09] .

[36:11] .

[36:13] .

[36:15] .

[36:17] .

[36:19] .

[36:21] .

[36:23] .

[36:25] .

[36:27] .

[36:29] .

[36:31] .

[36:33] .

[36:35] .

[36:37] .

[36:39] .

[36:41] .

[36:43] .

[36:45] .

[36:47] .

[36:49] .

[36:51] .

[36:53] .

[36:55] .

[36:57] .

[36:59] .

[37:01] .

[37:03] .

[37:05] .

[37:07] .

[37:09] .

[37:11] .

[37:13] .

[37:15] .

[37:17] .

[37:19] .

[37:21] .

[37:23] .

[37:25] .

[37:27] .

[37:29] .

[37:31] .

[37:33] .

[37:35] .

[37:37] .

[37:39] .

[37:41] .

[37:43] .

[37:45] .

[37:47] .

[37:49] .

[37:51] .

[37:53] .

[37:55] .

[37:57] .

[37:59] .

[38:01] .

[38:03] .

[38:05] .

[38:07] .

[38:09] .

[38:11] .

[38:13] .

[38:15] .

[38:17] .

[38:19] .

[38:21] .

[38:23] .

[38:25] .

[38:27] .

[38:29] .

[38:31] .

[38:33] .

[38:35] .

[38:37] .

[38:39] .

[38:41] .

[38:43] .

[38:45] .

[38:47] .

[38:49] .

[38:51] .

[38:53] .

[38:55] .

[38:57] .

[38:59] .

[39:01] .

[39:03] .

[39:05] .

[39:07] .

[39:09] .

[39:11] .

[39:13] .

[39:15] .

[39:17] .

[39:19] .

[39:21] .

[39:23] .

[39:25] .

[39:27] .

[39:29] .

[39:31] .

[39:33] .

[39:35] .

[39:37] .

[39:39] .

[39:41] .

[39:43] .

[39:45] .

[39:47] .

[39:49] .

[39:51] .

[39:53] .

[39:55] .

[39:57] .

[39:59] .

[40:01] .

[40:03] .

[40:05] .

[40:07] .

[40:09] .

[40:11] .

[40:13] .

[40:15] .

[40:17] .

[40:19] .

[40:21] .

[40:23] .

[40:25] .

[40:27] .

[40:29] .

[40:31] .

[40:33] .

[40:35] .

[40:37] .

[40:39] .

[40:41] .

[40:43] .

[40:45] .

[40:47] .

[40:49] .

[40:51] .

[40:53] .

[40:55] .

[40:57] .

[40:59] .

[41:01] .

[41:03] .

[41:05] .

[41:07] .

[41:09] .

[41:11] .

[41:13] .

[41:15] .

[41:17] .

[41:19] .

[41:21] .

[41:23] .

[41:25] .

[41:27] .

[41:29] .

[41:31] .

[41:33] .

[41:35] .

[41:37] .

[41:39] .

[41:41] .

[41:43] .

[41:45] .

[41:47] .

[41:49] .

[41:51] .

[41:53] .

[41:55] .

[41:57] .

[41:59] .

[42:01] .

[42:03] .

[42:05] .

[42:07] .

[42:09] .

[42:11] .

[42:13] .

[42:15] .

[42:17] .

[42:19] .

[42:21] .

[42:23] .

[42:25] .

[42:27] .

[42:29] .

[42:31] .

[42:33] .

[42:35] .

[42:37] .

[42:39] .

[42:41] .

[42:43] .

[42:45] .

[42:47] .

[42:49] .

[42:51] .

[42:53] .

[42:55] .

[42:57] .

[42:59] .

[43:01] .

[43:03] .

[43:05] .

[43:07] .

[43:09] .

[43:11] .